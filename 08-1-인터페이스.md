# 8-1. 인터페이스

인터페이스(interface) : 객체의 사용 방법을 정의한 타입 (객체 사용 설명서) 
> '개발코드' -(메소드호출)-> '인터페이스' -(메소드호출)-> '(구현)객체'  
'개발코드' <-(리턴값)- '인터페이스' <-(리턴값)- '(구현)객체'

- 인터페이스의 메소드를 호출 -> 객체 메소드 호출 가능 : 개발 코드에서 객체 내부 코드 알 필요 없음
- 인터페이스 쓰는 이유 : 개발 코드 수정 없이 객체 변경하기 위해 (인터페이스는 여러 객체들과 사용 가능)

클래스와 형태는 동일하나 선언 방식이 다름
```java
public interface 인터페이스명 {   // class 대신 interface 키워드를 사용해 선언
}
```

## 인터페이스 구성 

- 클래스의 구성 멤버 : 필드, 생성자, 메소드 
- 인터페이스의 구성 멤버 : 상수, 메소드 (자바7 이전: 추상 메소드만 -> 자바8 이후: 디폴트, 정적 메소드도 가능)

### 상수 필드(Constant Field)
객체 사용 설명서 = 인터페이스   
-> 런타임시 데이터 저장하는 필드 선언 불가 -> 대신 상수 필드는 선언 가능  

인터페이스 고정된 값으로, 상수 선언시 반드시 초기값 대입해야함
```java
public interface TestInterface {
    public static final 타입 상수명 = 값;     // 상수 필드 선언
    타입 상수명 = 값;     
    /* 
    인터페이스의 선언된 필드는 모두 public static final 특성을 가지기 때문에
    생략해도 컴파일 과정에서 붙음 (상수: 대문자. 언더바(_)로 단어 사이 연결) 
    */ 
}
```

### 추상 메소드(Abstract Method)
객체의 매개값과 리턴타입만 명세 (실제 실행 부분 -> 구현 객체)  
```java
public interface TestInterface {
    public abstract 리턴타입 메소드명(매개변수);     // 추상 메소드 선언
    리턴타입 메소드명(매개변수);  // 인터페이스의 추상메소드는 모두 public abstract 특성을 가짐 -> 생략해도 컴파일 과정에서 추가
}
```

### 디폴트 메소드(Default Method)
인터페이스에 선언 -> 사실, 구현 객체가 가지고 있는 인스턴스 메소드 (자바 8이상부터) 

디폴트 메소드 허용 이유 : 기존 인터페이스 확장 -> 새 기능 추가 목적
```java
public interface TestInterface {
    default 리턴타입 메소드명(매개변수) {   // 디폴트 메소드 선언 (default 키워드를 리턴 타입 앞에 붙임) 
        // 디폴트 메소드는 모두 public 속성 가짐 -> public 생략해도 컴파일 과정에서 추가
    }
}
```

### 정적 메소드(Static Method)
객체 없이 선언할 수 있는 특성답게 인터페이스 만으로 호출 가능 (자바 8이상부터)
```java
public interface TestInterface {
    static 리턴타입 메소드명(매개변수) {   // 정적 메소드 선언 (static 키워드를 리턴 타입 앞에 붙임) 
        // 정적 메소드는 모두 public 속성 가짐 -> public 생략해도 컴파일 과정에서 추가
    }
}
```


## 인터페이스 구현, 구현 클래스

> 개발코드 <-> 인터페이스 <-> 구현 객체

인터페이스를 구현한 실제 객체 = 인터페이스의 **구현(implement) 객체**  
구현 객체를 생성하는 클래스 = **구현 클래스**


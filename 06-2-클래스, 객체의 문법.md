# 6-2. 클래스, 객체의 문법

## 인스턴스(instance) 멤버

인스턴스 맴버 : 인스턴스(객체) 생성후 사용 가능한 필드, 메소드  
인스턴스 맴버 = 인스턴스 필드 + 인스턴스 메소드  

- 인스턴스 맴버 : 객체마다 따로 존재  
- 인스턴스 메소드 : 메소드 영역에 저장되고 공유됨

### this

객체는 자기자신 = **this** 라 함.  
```java
this.인스턴스맴버;
this.인스턴스메소드();
```

## 정적(static) 멤버

정적(static) 멤버 : 클래스에 고정된 멤버 = 객체 생성하지 않고 사용 가능한 필드, 메소드  
정적 멤버 = 정적 필드 + 정적 메소드
```java
// 정적 필드
static 타입 필드;

// 정적 메소드
static 리턴타입 메소드( ... ) { ... }
```
- 정적 메소드, 필드 : 클래스 로더가 클래스(바이트 코드) 로딩 -> 메소드 영역에 적재

- 인스턴스 필드 vs 정적 필드 : 객체마다 가지고 있을 데이터(인스턴스 필드) vs 객체마다 가지고 있을 필요가 없는 공용 데이터(정적 필드)
- 인스턴스 메소드 vs 정적 메소드 : 인스턴스 필드를 이용(인스턴스 메소드) vs 인스턴스 필드 안 씀(정적 메소드)

```java
// 정적 멤버 참조
클래스.정적필드;
클래스.정적메소드( ... );
```
정적 멤버는 클래스 이름으로 접근 (객체로도 접근 가능하지만 비권장)


### 정적 블록(static block)
```java
static double pi = 3.14159;
```
정적 필드는 보통 필드 선언과 동시에 초기값 정의  
정적 필드의 계산이 필요한 복잡한 초기화 작업은 **정적 블록(static block)** 이용  

```java
public class Test {
    static String name = "김동현";
    static int number = 2403;
    static String myId;
    static{
        myId = number + name;
    }
}
```

### 정적 메소드, 블록 주의점

정적 메소드, 정적 블록 : 객체가 없이도 실행 가능 -> 인스턴스 필드, 인스턴스 메소드, this 키워드 사용 불가  
인스턴스 맴버(필드, 메소드) 사용하려면 : 내부에 객체를 먼저 생성, 참조 변수로 접근해야 가능

### 싱글톤(Singleton)

싱글톤(Singleton) : 전체 프로그램 중 하나만 생성된 객체  
클래스 외부에서 생성자 호출을 막아야 함 -> 생성자 앞에 private 접근 제한자 사용   
-> 자신 타입의 정적 필드를 선언, 자신의 객체를 생성해 초기화 -> 정적 필드도 private 접근 제한자 사용  
-> 외부에서 호출가능한 정적 메소드 getInstance() 선언, 정적 필드에서 참조하는 자신의 객체를 리턴

```java
public class 클래스 {
    private static 클래스 singleton = new 클래스();   // 정적 필드 (private)
    private 클래스() {}    // 생성자 (private)
    static 클래스 getInstance() {      // 정적 메소드 (정적 필드에서 참조하는 자신의 객체 반환)
        return singleton;
    }
}
```
외부에서 객체(싱글톤)을 얻는 방법 : getInstancce() 메소드 호출하는 방법 1가지 밖에 없음


## final 필드, 상수(static final)

**final 필드** : 필드의 초기값 = 최종값, 프로그램 실행 중 수정 불가
```java
final 타입 필드 [= 초기값];
```
2가지 방법(필드 선언, 생성자에서)으로만 final 필드의 초기값을 줄 수 있음  
 
**상수(static final, constant)** : 변하지 않는 값

- final 필드 vs 상수(static final 필드) : 상수는 객체마다 저장할 필요 없는 '공용성' + 여러가지 값으로 초기화 불가
```java
static final 타입 상수 [= 초기값];
```
상수 이름은 모두 대문자가 관례 (단어 사이에 \_를 사용)  


## 패키지(package)

폴더로 파일을 저장, 관리 == 패키지로 클래스를 저장, 관리  

패키지는 클래스의 식별자 역할(패키지는 클래스의 일부) : 같은 클래스 명이여도 패키지가 다르면 다른 클래스로 인식
```java
패키지.클래스
상위패키지.하위패키지.클래스
```

패키지 : 클래스 컴파일 과정 -> 자동 생성 폴더  
컴파일러 : 클래스 포함된 패키지 선언 보고 파일 시스템 폴더로 자동 생성  
```java
package 상위패키지.하위패키지;

public class 클래스명 { ... }
```
#### 패키지 이름 명명 규칙
- 첫글자에 숫자, _와 $를 제외한 특수문자 사용 불가
- java로 시작하는 패키지 (-> 자바 표준 API에서만 사용) 사용 불가
- 모두 소문자로 작성이 관례

그외에도 다른 회사의 패키지 사용시, 도메인 이름으로 흔히 패키지 제작 (도메인 역순으로 패키지 이름을 지어줌)
```java
com.samsung.프로젝트명
com.lg.프로젝트명
```

패키지 선언이 포함된 클래스 -> javac 명령어에 -d 옵션을 추가 + 패키지 생성 경로 지정  
`````javac -d 경로 클래스명.java```

### import 문

다른 패키지의 클래스를 사용할 때, ```package 패키지명``` 
-> 사용하는 다른 패키지 클래스 사용시 패키지 이름을 모두 기술해야 함

패키지를 **import 문** 으로 선언 -> 다른 패키지 클래스 사용시 패키지 이름 생략 가능

```java
package 상위패키지.하위패키지;

import 상위패키지.하위패키지.*;   // import 상위패키지.하위패키지.클래스명; 으로 특정 클래스만 추가 가능
``` 
import 문 위치 : 패키지 선언, 클래스 선언 사이   

동일한 클래스명의 클래스를 가진 패키지들을 모두 import -> 클래스명 중복 -> 컴파일 에러


## 접근제한자 

접근제한|적용대상|접근 가능한 클래스
:---:|:---:|:---:
public|클래스, 필드, 생성자, 메소드|모두
protected|필드, 생성자, 메소드|같은 페키지 클래스 + 자식 클래스
default|클래스, 필드, 생성자, 메소드|같은 패키지의 클래스
private|필드, 생성자, 메소드|해당 클래스에서만

접근 제한자를 명시 안함 -> **default 접근 제한자**

- 기본 생성자는 클래스의 접근 제한과 동일


## Getter, Setter 메소드

일반적인 OOP : 객체 데이터의 외부 직접 접근을 막음 (객체의 무결성 때문)  
-> 대신 메소드를 통해 데이터 접근을 유도 (메소드가 매개값을 검증해 유호한 값만 데이터로 저장할 수 있기 때문)

- Setter 메소드 : 객체의 데이터를 변경하는 메소드 (메소드명 set으로 시작하는 것이 관례)
- Getter 메소드 : 객체의 데이터를 변경하는 메소드 (메소드명 get으로 시작하는 것이 관례) (필드 타입이 boolean이면 is로 시작하는 것이 관례)


## 어노테이션 (Annotation)

어노테이션 = 메타데이터(metadata) : 컴파일, 실행 과정에서 어떻게 컴파일, 처리할 지 알려주는 정보




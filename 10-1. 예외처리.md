# 10-1. 예외 처리

**예러(error)** : (하드웨어 오동작, 고장 등으로) 응용프로그램 실행 오류가 발생하는 것  
= JVM 실행에 문제 발생 (프로그램과 별개로 실행 불능이 됨)

**예외(exception)** : 사용자 또는 개발자의 조작, 코딩으로 발생하는 프로그램 오류  
-> 발생시 프로그램이 종료되는 것에서 에러와 동일  
-> 예외 처리(Exception Handing) 통해 정상 실행 상태 유지 가능

예외는 2가지 종류 존재

1. 일반 예외(Exception)    
    = 컴파일러 체크 예외 (자바 소스 컴파일 과정에서 예외 처리 코드를 검사하기 때문)  

2. 실행 예외(Runtime Exception)   
    컴파일 과정에서 예외 처리 코드를 검사하지 않는 예외

**두가지 예외 모두 예외 처리 필요**

JVM은 프로그램 실행중 에러 발생시 해당 예외 클래스로 객체 생성  
-> 예외 처리 코드에서 예외 객체 활용하게 해줌 

모든 예외 클래스는 java.lang.Exception 클래스를 상속 받음  
Exception을 상속받는 일반 예외 클래스와 달리 실행 예외 클래스는 RuntimeException(사실 이것도 Exception의 하위 클래스)을 상속 받음 


## 자주 발생되는 실행 예외

실행 예외는 자바 컴파일러가 체크 안함 -> 예외 처리 코드 없이 해당 실행 예외가 발생하면 프로그램 곧바로 종료  

#### NullPointerException

자바에서 가장 빈번하게 발생되는 에러,  
객체 참조가 없는 (null 값을 가지는) 참조 변수로 객체 접근 연산자, 도트(.)를 사용해서 멤버를 사용했을 때 발생

#### ArrayIndexOutOfBoundsException

배열의 인덱스 범위를 초과해 사용할 때 발생,  
**배열 값 읽기전, 배열 길이 검사로 예방**

#### NumberFormatException

문자열을 숫자로 변환할 때, 문자열에서 숫자로 변환할 수 없는 문자가 포함되있을 때 발생

#### ClassCastException

타입 변환(Casting)은 상속관계의 클래스 사이거나, 인터페이스와 구현 클래스 사이에만 가능  
-> 이 관계가 아닌데 억지로 타입 변환을 시도하면 이 에러 발생   
**instanceof 연산자로 타입 변환이 가능한지 검사로 예방**


## 예외 처리 코드

**try-catch-finally 블록 이용**  
```java
try {
    // 예외 발생 가능한 코드
} catch(예외클래스 e) {
    // 예외 발생시 예외 처리
} finally {
    // 항상 실행
}
```
finally 블록은 생략 가능 (예외 발생 여부 상관없이 실행할 내용이 있을 경우에 finally 사용)  
**try, catch 블록에서 return문 사용해도 finally 블록은 항상 실행**  


### 다중 catch

```java
try {
    // 여러개의 예외 발생 가능한 코드
} catch(예외1클래스 e) {
    // 예외1 처리
} catch(예외2클래스 e) {
    // 예외2 처리
} 
```
다중 catch 블록에서 상위 예외 클래스가 위에 있다면, 아래에 있는 하위 예외 클래스가 처리되지 않음  
-> **다중 catch 블록에선 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치해야 함**

### 멀티 catch
: 다중 catch랑 이름이 헷갈리는데, **하나의 catch 블록에서 여러 개의 예외를 처리 = 멀티 catch**

```java
try {
    // 여러개의 예외 발생 가능한 코드
} catch(예외1클래스 e | 예외2클래스 e) {
    // 예외 1, 2 처리
}
```
멀티 catch랑 다중 catch랑 같이 사용 가능


## 자동 리소스 종료 
리소스(입출력 스트림, 서버 소켓, 소켓, 각종 채널)에서 예외 발생  
-> finally 블록에서 close()를 try-catch로 다시 예외처리 해서 리소스를 종료

자바 7부터 ```try-with-resources```를 사용해서 예외 발생 여부 상관없이 리소스 객체를 안전하고 간단하게 종료
```java
try (리소스명 리소스변수명 = new 리소스명()){
    // 리소스 처리 코드
} catch(예외클래스 e) {
    // 리소스에서 발생한 예외 처리 코드
}
```
close() : try에서 정상 실행 완료 or 예외 발생시 자동으로 호출 (명시할 필요 없음)

사용할 리소스가 여러개면 아래처럼 작성
```java
try (
    리소스1 리소스1변수명 = new 리소스1();
    리소스2 리소스2변수명 = new 리소스2();
){
    // 리소스 처리 코드
} catch(예외클래스 e) {
    // 리소스에서 발생한 예외 처리 코드
}
```

- **AutoCloseable 인터페이스를 구현하는 리소스 객체만 try-with-resources 사용 가능**


## 예외 떠넘기기


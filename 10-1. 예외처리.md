# 10-1. 예외 처리

**예러(error)** : (하드웨어 오동작, 고장 등으로) 응용프로그램 실행 오류가 발생하는 것  
= JVM 실행에 문제 발생 (프로그램과 별개로 실행 불능이 됨)

**예외(exception)** : 사용자 또는 개발자의 조작, 코딩으로 발생하는 프로그램 오류  
-> 발생시 프로그램이 종료되는 것에서 에러와 동일  
-> 예외 처리(Exception Handing) 통해 정상 실행 상태 유지 가능

예외는 2가지 종류 존재

1. 일반 예외(Exception)    
    = 컴파일러 체크 예외 (자바 소스 컴파일 과정에서 예외 처리 코드를 검사하기 때문)  

2. 실행 예외(Runtime Exception)   
    컴파일 과정에서 예외 처리 코드를 검사하지 않는 예외

**두가지 예외 모두 예외 처리 필요**

JVM은 프로그램 실행중 에러 발생시 해당 예외 클래스로 객체 생성  
-> 예외 처리 코드에서 예외 객체 활용하게 해줌 

모든 예외 클래스는 java.lang.Exception 클래스를 상속 받음  
Exception을 상속받는 일반 예외 클래스와 달리 실행 예외 클래스는 RuntimeException(사실 이것도 Exception의 하위 클래스)을 상속 받음 


## 자주 발생되는 실행 예외

실행 예외는 자바 컴파일러가 체크 안함 -> 예외 처리 코드 없이 해당 실행 예외가 발생하면 프로그램 곧바로 종료  

#### NullPointerException

자바에서 가장 빈번하게 발생되는 에러,  
객체 참조가 없는 (null 값을 가지는) 참조 변수로 객체 접근 연산자, 도트(.)를 사용해서 멤버를 사용했을 때 발생

#### ArrayIndexOutOfBoundsException

배열의 인덱스 범위를 초과해 사용할 때 발생,  
**배열 값 읽기전, 배열 길이 검사로 예방**

#### NumberFormatException

문자열을 숫자로 변환할 때, 문자열에서 숫자로 변환할 수 없는 문자가 포함되있을 때 발생

#### ClassCastException

타입 변환(Casting)은 상속관계의 클래스 사이거나, 인터페이스와 구현 클래스 사이에만 가능  
-> 이 관계가 아닌데 억지로 타입 변환을 시도하면 이 에러 발생   
**instanceof 연산자로 타입 변환이 가능한지 검사로 예방**


## 예외 처리 코드

**try-catch-finally 블록 이용**  
```java
try {
    // 예외 발생 가능한 코드
} catch(예외클래스 e) {
    // 예외 발생시 예외 처리
} finally {
    // 항상 실행
}
```
finally 블록은 생략 가능 (예외 발생 여부 상관없이 실행할 내용이 있을 경우에 finally 사용)  
**try, catch 블록에서 return문 사용해도 finally 블록은 항상 실행**  


### 다중 catch

```java
try {
    // 여러개의 예외 발생 가능한 코드
} catch(예외1클래스 e) {
    // 예외1 처리
} catch(예외2클래스 e) {
    // 예외2 처리
} 
```
다중 catch 블록에서 상위 예외 클래스가 위에 있다면, 아래에 있는 하위 예외 클래스가 처리되지 않음  
-> **다중 catch 블록에선 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치해야 함**

### 멀티 catch
: 다중 catch랑 이름이 헷갈리는데, **하나의 catch 블록에서 여러 개의 예외를 처리 = 멀티 catch**

```java
try {
    // 여러개의 예외 발생 가능한 코드
} catch(예외1클래스 e | 예외2클래스 e) {
    // 예외 1, 2 처리
}
```
멀티 catch랑 다중 catch랑 같이 사용 가능


## 자동 리소스 종료 
리소스(입출력 스트림, 서버 소켓, 소켓, 각종 채널)에서 예외 발생  
-> finally 블록에서 close()를 try-catch로 다시 예외처리 해서 리소스를 종료

자바 7부터 ```try-with-resources```를 사용해서 예외 발생 여부 상관없이 리소스 객체를 안전하고 간단하게 종료
```java
try (리소스명 리소스변수명 = new 리소스명()){
    // 리소스 처리 코드
} catch(예외클래스 e) {
    // 리소스에서 발생한 예외 처리 코드
}
```
close() : try에서 정상 실행 완료 or 예외 발생시 자동으로 호출 (명시할 필요 없음)

사용할 리소스가 여러개면 아래처럼 작성
```java
try (
    리소스1 리소스1변수명 = new 리소스1();
    리소스2 리소스2변수명 = new 리소스2();
){
    // 리소스 처리 코드
} catch(예외클래스 e) {
    // 리소스에서 발생한 예외 처리 코드
}
```

- **AutoCloseable 인터페이스를 구현하는 리소스 객체만 try-with-resources 사용 가능**


## 예외 처리 떠넘기기

메소드 내부에서 예외 처리하지 않고, 메소드를 호출한 곳에서 예외 처리를 떠넘길 수 있음 -> **throws 사용**

```java
리턴타입 메소드명(매개변수) throws 예외클래스 {
    // 메소드 내용
}


// 메소드를 호출한 곳
try {
    메소드명(인자값); 
} catch(예외클래스 e) {
    // 예외 처리
}
``` 
이렇게 되면 throws 키워드가 붙은 메소드가 호출되서 실행 중에 throws에 명시한 예외가 발생하면,  
예외 처리를 메소드가 호출된 곳으로 떠넘김, 메소드 호출한 곳에서는 받아온 예외를 try-catch 문으로 처리

```java
리턴타입 메소드명(매개변수) throws 예외클래스1, 예외클래스2 {     // 여러 예외 클래스도 가능
    // 메소드 내용
}

리턴타입 메소드명(매개변수) throws Exception {     // Exception으로 모든 예외도 가능
    // 메소드 내용
}
``` 
사실 예외 처리를 **throws로 떠넘기는 것도 여러번 사용 가능**  
심지어 main() 메소드에서도 예외 처리를 throws로 떠넘길 수 있음 -> 그렇게 되면 JVM이 최종적으로 예외 처리  
= JVM이 예외 처리하는 것은 좋지 않은 예외 처리 방법 : main() 에서 try-catch 블록으로 예외를 최종 처리하는 것이 권장


## 사용자 정의 예외

자바 표준 API 에는 없지만 개발하는 애플리케이션에서 필요한 예외 = 애플리케이션 예외(Application Exception) = 사용자 정의 예외 (사용자가 직접 정의해야 하기에)

```java
public class 사용자정의예외명 extends [Exception or RuntimeException] {
    public 사용자정의예외명() { }
    public 사용자정의예외명(String message) { super(message); }
}
```
**사용자 정의 예외 클래스명 = Exception 으로 끝나는 것을 권장**  
일반 예외라면 Exception을 상속, 실행 예외라면 RuntimeException을 상속  

사용자 정의 예외 클래스에서도 다양한 멤버 포함 가능 -> **일반적으로 2가지 생성자 선언만** 포함
- 기본 생성자 
- 예외 메시지를 전달하기 위해 String 타입의 매개변수를 갖는 생성자 : 상위 클래스 생성자를 호출해 예외 메시지를 넘겨줌  

```java
throw new 사용자정의예외명();
```
위 코드로 사용자 정의 예외를 발생시킬 수 있음


## 예외 메시지 얻기

catch문에서 e변수로 받은 예외 클래스는 모두 Exception 클래스를 상속 받음,  
그래서 Exception 클래스의 메소드들을 모든 예외 객체에서 호출 가능 -> 그중 많이 쓰이는 메소드 : **getMessage(), printStackTrace()**

- 예외객체.getMessage() : 예외 코드나 메시지(예외가 발생한 것에 대한 설명)가 반환
- 예외객체.printStackTrace() : 예외가 발생한 경로를 추적해서 상세하게 출력

# 13-1. 람다식

**람다식(Lambda Expressions)** : 익명 함수(anonymous function)을 생성하는 식, 자바 8부터 사용  

(코드상) 매개변수가 있는 코드 블록 -> (런타임 시) 익명 구현 객체
```java
인터페이스명 변수명 = new 인터페이스명() {
    접근제한자 리턴값 메소드명() { ... }
}
// 와 같은 익명 구현 객체를 

인터페이스명 변수명 = () -> { ... };
// 와 같이 한줄로 바꾼게 람다식
```
람다식은 ```(매개변수) -> {실행코드}```의 형식으로 함수 형태지만, 인터페이스의 익명 구현 객체가 생성  

## 람다식 기본 문법

함수 스타일의 람다식 형식은
```java
(타입 매개변수) -> { 실행문; ... }

(a, b) -> { System.out.println(a, b); } // 예시
// 매개변수의 타입은 언급하지 않음 -> 런타임 때 대입되는 값에 따라서 자동 인식 가능해서 
```
이며, 아래처럼 생략할 수 있다.
```java
a -> { System.out.println(a); }     // 매개변수가 하나면 괄호(()) 생략 가능
a -> System.out.println(a)     // 실행문이 하나면 대괄호(스코프, {}) 생략 가능
() -> { 실행문; ... }      // 매개변수가 없으면 빈 괄호 생략 불가, 반드시 괄호 사용

(x, y) -> { return x + y; }     // 람다식도 return 문 사용 가능 
(x, y) -> x + y     // 실행문이 return 문만 있을시 이렇게 작성 
```

## 타겟 타입, 함수적 인터페이스

람다식은 메소드를 선언하는 것처럼 보이지만, 자바는 메소드 단독 선언 불가  
-> 람다식으 메소드를 가진 객체를 생성하는데, 그 객체의 타입은 인터페이스의 구현 객체
```java
인터페이스명 변수명 = 람다식;   // 인터페이스의 구현 객체를 람다식이 생성
```

- 람다식의 **타겟 타입(target type)** : 람다식이 대입될 변수의 인터페이스

모든 인터페이스를 람다식의 타겟 타입으로 사용 불가 -> 람다식은 하나의 메소드를 정의하기에 추상 메소드가 2개 이상이면 람다식 사용 불가   
-> **하나의 추상 메소드가 선언된 인터페이스만 람다식의 타겟 타입으로 사용 가능**

- **함수적 인터페이스(functional interface)** : 하나의 추상 메소드가 선언된 인터페이스  

함수적 인터페이스 선언 : 어노테이션으로 두개 이상 추상 메소드가 선언되지 않게 컴파일러가 체킹 가능
```java
@FunctionalInterface    // 추상 메소드가 2개 이상 이면, 컴파일 오류 발생
public interface 인터페이스명 { ... }
```
```@FunctionalInterface``` 는 선택사항 (어노테이션 없이도 함수적 인터페이스 작성 가능, 2개 이상 추상 메소드 선언 방지용)


**람다식은 타겟 타입(인터페이스)의 추상 메소드에 따라 구현해야 함**
- 타겟 타입(인터페이스)의 추상 메소드명으로 람다식의 함수 호출 가능 
```java
인터페이스명 참조변수명 = () -> { ... }    // 인터페이스 참조 변수에 람다식 대입 
참조변수명.추상메소드명();   // 람다식의 함수 호출
```
- 추상 메소드가 가진 매개변수를 따라, 람다식의 매개변수 작성 (매개변수 없으면 람다식도 없고, 매개변수 개수만큼 람다식도 있어야 함)
- 추상 메소드가 리턴값을 가지는가 따라, 람다식에 return문 작성 (리턴값 없으면 람다식도 없고, 리턴값 있으면 람다식에 return 문 있어야 함)

## 클래스 멤버, 로컬 변수 사용

람다식 실행 블록 -> **바깥 클래스 멤버(메소드, 필드)는 제약 없이** 사용 가능, **로컬 변수는 제약** 존재
 
1. ### 클래스 멤버

람다식에서 바깥 클래스의 멤버(필드, 메소드)는 제약 없이 사용 가능  
- **this** 키워드 : (일반적 익명 객체 내부의 this = 익명 객체 자신 참조,) **람다식에서 this = 람다식을 실행한 객체 참조**   
```java
public class Outer {
    class Inner {
        void method() {
            MyFunctionalInterface fi = () -> {      // 람다식
                Outer.this.멤버명      // 바깥 객체를 참조하려면, `클래스명.this` 사용
                this.멤버명            // `this`는 람다식을 실행한 객체(여기선 Inner) 참조
            }   
        }
    }
}
```

2. ### 로컬 변수 사용

> 익명 객체에서의 외부 멤버 참조 제한과 동일

람다식은 주로 메소드 내부에 작성 -> **객체나 람다식이 만드는 (익명 구현)객체는 소멸되지 않음** vs **메소드와 메소드의 매개변수, 로컬변수는 실행이 끝나면 소멸**  
-> 메소드의 매개변수, 로컬변수를 참조하려면 **final 특성** 가져야 함 (읽기만 가능)    
